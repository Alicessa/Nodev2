/*!
 * @templatejs/runtime 2.3.0 (https://github.com/yanhaijing/runtime)
 * API https://github.com/yanhaijing/runtime/blob/master/doc/api.md
 * Copyright 2017-2019 yanhaijing. All Rights Reserved
 * Licensed under MIT (https://github.com/yanhaijing/runtime/blob/master/LICENSE)
 */

'use strict';

var type = require('@jsmini/type');
var extend = require('@jsmini/extend');

var o = {
    sTag: '<%',
    eTag: '%>',
    compress: false,
    escape: true,
    error: function () { } //错误回调
};
function clone() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return extend.extend.apply(null, [{}].concat(args));
}
function nothing(param) {
    return param;
}
function encodeHTML(source) {
    return String(source)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\\/g, '&#92;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}
var functionMap = {}; //内部函数对象
//修饰器前缀
var modifierMap = {
    '': function (param) { return nothing(param); },
    'h': function (param) { return encodeHTML(param); },
    'u': function (param) { return encodeURI(param); }
};
function consoleAdapter(cmd, msg) {
    typeof console !== 'undefined' && console[cmd] && console[cmd](msg);
}
function runtime() { }
runtime.config = function (option) {
    if (type.type(option) === 'object') {
        o = extend.extend(o, option);
    }
    return clone(o);
};
runtime.compress = function (html) {
    return String(html).replace(/\s+/g, ' ').replace(/<!--[\w\W]*?-->/g, '');
};
runtime.handelError = function handelError(e) {
    var message = 'template.js error\n\n';
    for (var key in e) {
        message += '<' + key + '>\n' + e[key] + '\n\n';
    }
    message += '<message>\n' + e.message + '\n\n';
    consoleAdapter('error', message);
    o.error(e);
    function error() {
        return 'template.js error';
    }
    error.toString = function () {
        return '__code__ = "template.js error"';
    };
    return error;
};
runtime.registerFunction = function (name, fn) {
    if (typeof name !== 'string') {
        return clone(functionMap);
    }
    if (type.type(fn) !== 'function') {
        return functionMap[name];
    }
    return functionMap[name] = fn;
};
runtime.unregisterFunction = function (name) {
    if (typeof name !== 'string') {
        return false;
    }
    delete functionMap[name];
    return true;
};
runtime.registerModifier = function (name, fn) {
    if (typeof name !== 'string') {
        return clone(modifierMap);
    }
    if (type.type(fn) !== 'function') {
        return modifierMap[name];
    }
    return modifierMap[name] = fn;
};
runtime.unregisterModifier = function (name) {
    if (typeof name !== 'string') {
        return false;
    }
    delete modifierMap[name];
    return true;
};
runtime.encodeHTML = encodeHTML;
runtime.functionMap = functionMap;
runtime.modifierMap = modifierMap;
runtime.o = o;

module.exports = runtime;
